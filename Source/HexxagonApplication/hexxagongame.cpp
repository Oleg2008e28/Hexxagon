/**
* @file hexxagongame.cpp
* @author Oleg2008e28
* @date 31.12.2024 17:35:10
* @brief Файл реализации методов класса Game.
* @note https://github.com/Oleg2008e28/Hexxagon
*/    
#include "hexxagongame.h"
//............................................................................................................
//.......................................... public methods ..................................................
//............................................................................................................
/**
 * @brief Game::Game Конструктор класса Game
 * @param parent Родительский объект.
 */
Game::Game(QObject *parent): QObject(parent){
    state = State::none;                                        // Состояние игрового автомата, остановлен.
    modeGame = Mode::none;                                      // Режим не определен
    activePlayer = 0;                                           // Активный игрок не назначен.
    currentIndex = 0;                                           // Текущий индекс.
    gameDepth_1 = 0;                                            // Глубина рекурсии не выбрана.
    gameDepth_2 = 0;                                            // Глубина рекурсии не выбрана.
    field = clearField;                                         // Загрузка стартового поля.
    future = new QFuture<Move>;                                 // Создание будущего объекта для хода ПК.
    timer = new QTimer(this);                                   // Созидание таймера вычисления хода ПК.
}
/**
 * @brief Game::~Game Деструктор класса Game.
 */
Game::~Game(){
    delete future;                                              // Удаление динамически созданных объектов.
    delete timer;
}
/**
 * @brief Game::pauseOn Метод ставит на паузу выполнение хода компьютером.
 */
void Game::pauseOn(){
    if (state == State::witePcMove){
        disconnect(timer, SIGNAL(timeout()),                    // Отключение сигнала таймера от слота
                   this, SLOT(computerMove()));                 // хода компьютера.
    }
}
/**
 * @brief Game::pauseOff Метод отключает паузу хода компьютера.
 */
void Game::pauseOff(){
    if (state == State::witePcMove){
        connect(timer, SIGNAL(timeout()),                       // Подключение сигнала таймера к слоту
                   this, SLOT(computerMove()));                 // хода компьютера.
    }
}
/**
 * @brief Game::gameReset Метод остановки игры, и подготовки игрового автомата к новой игре.
 */
void Game::gameReset(){
    timer->stop();                          // Остановка таймера ожидания хода ПК при игре против человека.
    disconnect(timer, SIGNAL(timeout()),    // Отключение сигнала таймера от слота хода компьютера.
               this, SLOT(computerMove()));
    modeGame = Mode::none;                  // Режим не определен
    activePlayer = 0;                       // Активный игрок не назначен.
    currentIndex = 0;                       // Текущий индекс.
    gameDepth_1 = 0;                        // Глубина рекурсии не выбрана.
    gameDepth_2 = 0;                        // Глубина рекурсии не выбрана.
    field = clearField;                     // Загрузка стартового поля.
    state = State::none;                    // Состояние игрового автомата, остановлен.
    emit transmitField(field);              // Сигнал о передаче состояния поля.
    emit clearAvailableMove();              // Сигнал для отмены отображения доступных ходов.
}
/**
 * @brief Game::getActivePlayer Метод возвращает значение текущего игрока.
 * @return Номер игрока, который должен сделать ход.
 */
int Game::getActivePlayer( ){
    return activePlayer;
}
/**
 * @brief Game::getDepth_1 Метод возвращает глубину рекурсии для компьютера 1.
 * @return Глубина рекурсии 1.
 */
int Game::getDepth_1(){
    return gameDepth_1;
}
/**
 * @brief Game::getDepth_2 Метод возвращает глубину рекурсии для компьютера 1.
 * @return Глубина рекурсии 2.
 */
int Game::getDepth_2(){
    return gameDepth_2;
}
/**
 * @brief Game::getField Метод возвращает текущее состояние игрового поля.
 * @return Состояние игрового поля.
 */
QVector<int8_t> Game::getField(){
    return field;
}
/**
 * @brief Game::getModeGame Метод возвращает текущий режим игры.
 * @return Текущий режим игры.
 */
Game::Mode Game::getModeGame(){
    return modeGame;
}
/**
 * @brief Game::start Метод запуска игры.
 * @param beginPlayer Игрок который начинает игру.
 * @param mode Режим игры.
 * @param depth_1 Глубина рекурсии для компьютера 1. (По умолчанию 0. Для игры человек против человека не
 * используется. Используется в режиме игры с компьютером, как глубина рекурсии для компьютера, и в режиме
 * компьютер против компьютера, как глубина рекурсии для компьютера 1.
 * @param depth_2 Глубина рекурсии для компьютера 2. (По умолчанию 0. Для игры человек против человека и
 * человека против компьютера не используется. Используется в режиме игры компьютер против компьютера,
 * как глубина рекурсии для компьютера 2.
 */
void Game::start(int beginPlayer, Mode mode, int depth_1, int depth_2){
    activePlayer = beginPlayer;                             // Установка текущего игрока.
    modeGame = mode;                                        // установка режима игры.
    gameDepth_1 = depth_1;                                  // Установка глубины рекурсии 1.
    gameDepth_2 = depth_2;                                  // Установка глубины рекурсии 2.
    field = startField;                                     // Установка стартового состояния поля.
    emit transmitField(field);                              // Сигнал о передаче состояния поля.
    emit transmitPlayer(activePlayer);                      // Сигнал передачи текущего игрока.
    emit transmitScore(counterChips(1), counterChips(2));   // Сигнал передачи игрового счета.
        if (modeGame == Mode::humanVShuman                  // Если режим игры человек - человека,
                || modeGame == Mode::humanVSpc){            // или человек против компьютера,
            state = State::waitIndex;                       // Автомат в состояние ожидания индекса
        } else                                              // ячейки, выбранной пользователем.
        if (modeGame == Mode::pcVSpc){                      // Если режим работы ПК против ПК,
            state = State::witePcMove;                      // Автомат переходит в режиме ожидания.
            computerMove();                                 // Запускается выполнение хода компьютера.
        }
}
//............................................................................................................
//........................................ protected methods .................................................
//............................................................................................................
/**
 * @brief Game::getAddMoveCells Метод возвращает индексы ячеек доступных для выполнения ближнего хода.
 * @param field Состояние игрового поля.
 * @param n Индекс ячейки, для которой вычисляются ходы.
 * @return Вектор индексов доступных для хода ячеек.
 */
QVector<int8_t> Game::getAddMoveCells(QVector<int8_t> const& field, int8_t n) {
    QVector<int8_t> pV = getNearCells(n);                                           // Вектор для сохранения
    for (int i = 0; i < field.size(); i++) {                                        // найденных ячеек.
        if (field[i] != 0) {
            QVector<int8_t>::iterator it = std::find(pV.begin(), pV.end(), i);      // Итератор для поиска.
            if (it!= pV.end()) {
                pV.erase(it);
            }
        }
    }
    return pV;
}
/**
 * @brief Game::getFarCells Метод определяет индексы ячеек для дальнего хода.
 * @param n Индекс выбранной ячейки.
 * @return Вектор индексов ячеек для дальнего хода.
 */
QVector<int8_t> Game::getFarCells(int8_t n) {
    QVector<int8_t> pV;                     // Вектор индексов ячеек для дальнего хода.
    int8_t begin_1 = 0;                     // Начальный индекс дальнего слева столбца.
    int8_t end_1 = 0;                       // Конечный индекс дальнего слева столбца.
    int8_t a_1 = 0;                         // Смещение 1 для дальнего слева столбца.
    int8_t b_1 = 0;                         // Смещение 2 для дальнего слева столбца.
    int8_t c_1 = 0;                         // Смещение 3 для дальнего слева столбца.

    int8_t begin_2 = 0;                     // Начальный индекс ближнего слева столбца.
    int8_t end_2 = 0;                       // Конечный индекс ближнего слева столбца.
    int8_t a_2 = 0;                         // Смещение 1 для ближнего слева столбца.
    int8_t b_2 = 0;                         // Смещение 2 для ближнего слева столбца.

    int8_t begin_3 = 0;                     // Начальный индекс текущего столбца.
    int8_t end_3 = 0;                       // Конечный индекс текущего столбца.

    int8_t begin_4 = 0;                     // Начальный индекс ближнего справа столбца.
    int8_t end_4 = 0;                       // Конечный индекс ближнего справа столбца.
    int8_t a_4 = 0;                         // Смещение 1 для ближнего справа столбца.
    int8_t b_4 = 0;                         // Смещение 2 для ближнего справа столбца.

    int8_t begin_5 = 0;                     // Начальный индекс дальнего справа столбца.
    int8_t end_5 = 0;                       // Конечный индекс дальнего справа столбца.
    int8_t a_5 = 0;                         // Смещение 1 для дальнего справа столбца.
    int8_t b_5 = 0;                         // Смещение 2 для дальнего справа столбца.
    int8_t c_5 = 0;                         // Смещение 3 для дальнего справа столбца.
//............................................................................................................
    if (n >= 0 && n <= 4) {                 // Если заданная ячейка находится в первом столбце поля.
        begin_3 = 0;                        // Начальный индекс текущего столбца.
        end_3 = 4;                          // Конечный индекс текущего столбца.
        begin_4 = 5;                        // Начальный индекс ближнего справа столбца.
        end_4 = 10;                         // Конечный индекс ближнего справа столбца.
        a_4 = 4;                            // Смещение 1 для ближнего справа столбца.
        b_4 = 7;                            // Смещение 2 для ближнего справа столбца.
        begin_5 = 11;                       // Начальный индекс дальнего справа столбца.
        end_5 = 17;                         // Конечный индекс дальнего справа столбца.
        a_5 = 11;                           // Смещение 1 для дальнего справа столбца.
        b_5 = 12;                           // Смещение 2 для дальнего справа столбца.
        c_5 = 13;                           // Смещение 3 для дальнего справа столбца.
    }
    if (n >= 5 && n <= 10) {                // Если заданная ячейка находится во втором столбце поля.
        begin_2 = 0;                        // Начальный индекс ближнего слева столбца.
        end_2 = 4;                          // Конечный индекс ближнего слева столбца.
        a_2 = -7;                           // Смещение 1 для ближнего слева столбца.
        b_2 = -4;                           // Смещение 2 для ближнего слева столбца.

        begin_3 = 5;                        // Начальный индекс текущего столбца.
        end_3 = 10;                         // Конечный индекс текущего столбца.

        begin_4 = 11;                       // Начальный индекс ближнего справа столбца.
        end_4 = 17;                         // Конечный индекс ближнего справа столбца.
        a_4 = 5;                            // Смещение 1 для ближнего справа столбца.
        b_4 = 8;                            // Смещение 2 для ближнего справа столбца.

        begin_5 = 18;                       // Начальный индекс дальнего справа столбца.
        end_5 = 25;                         // Конечный индекс дальнего справа столбца.
        a_5 = 13;                           // Смещение 1 для дальнего справа столбца.
        b_5 = 14;                           // Смещение 2 для дальнего справа столбца.
        c_5 = 15;                           // Смещение 3 для дальнего справа столбца.
    }
    if (n >= 11 && n <= 17) {               // Если заданная ячейка находится в третьем столбце поля.
        begin_1 = 0;                        // Начальный индекс дальнего слева столбца.
        end_1 = 4;                          // Конечный индекс дальнего слева столбца.
        a_1 = -13;                          // Смещение 1 для дальнего слева столбца.
        b_1 = -12;                          // Смещение 2 для дальнего слева столбца.
        c_1 = -11;                          // Смещение 3 для дальнего слева столбца.

        begin_2 = 5;                        // Начальный индекс ближнего слева столбца.
        end_2 = 10;                         // Конечный индекс ближнего слева столбца.
        a_2 = -8;                           // Смещение 1 для ближнего слева столбца.
        b_2 = -5;                           // Смещение 2 для ближнего слева столбца.

        begin_3 = 11;                       // Начальный индекс текущего столбца.
        end_3 = 17;                         // Конечный индекс текущего столбца.

        begin_4 = 18;                       // Начальный индекс ближнего справа столбца.
        end_4 = 25;                         // Конечный индекс ближнего справа столбца.
        a_4 = 6;                            // Смещение 1 для ближнего справа столбца.
        b_4 = 9;                            // Смещение 2 для ближнего справа столбца.

        begin_5 = 26;                       // Начальный индекс дальнего справа столбца.
        end_5 = 34;                         // Конечный индекс дальнего справа столбца.
        a_5 = 15;                           // Смещение 1 для дальнего справа столбца.
        b_5 = 16;                           // Смещение 2 для дальнего справа столбца.
        c_5 = 17;                           // Смещение 3 для дальнего справа столбца.
    }
    if (n >= 18 && n <= 25) {               // Если заданная ячейка находится в четвертом столбце поля.
        begin_1 = 5;                        // Начальный индекс дальнего слева столбца.
        end_1 = 10;                         // Конечный индекс дальнего слева столбца.
        a_1 = -15;                          // Смещение 1 для дальнего слева столбца.
        b_1 = -14;                          // Смещение 2 для дальнего слева столбца.
        c_1 = -13;                          // Смещение 3 для дальнего слева столбца.

        begin_2 = 11;                       // Начальный индекс ближнего слева столбца.
        end_2 = 17;                         // Конечный индекс ближнего слева столбца.
        a_2 = -9;                           // Смещение 1 для ближнего слева столбца.
        b_2 = -6;                           // Смещение 2 для ближнего слева столбца.

        begin_3 = 18;                       // Начальный индекс текущего столбца.
        end_3 = 25;                         // Конечный индекс текущего столбца.

        begin_4 = 26;                       // Начальный индекс ближнего справа столбца.
        end_4 = 34;                         // Конечный индекс ближнего справа столбца.
        a_4 = 7;                            // Смещение 1 для ближнего справа столбца.
        b_4 = 10;                           // Смещение 2 для ближнего справа столбца.

        begin_5 = 35;                       // Начальный индекс дальнего справа столбца.
        end_5 = 42;                         // Конечный индекс дальнего справа столбца.
        a_5 = 16;                           // Смещение 1 для дальнего справа столбца.
        b_5 = 17;                           // Смещение 2 для дальнего справа столбца.
        c_5 = 18;                           // Смещение 3 для дальнего справа столбца.
    }
    if (n >= 26 && n <= 34) {               // Если заданная ячейка находится в пятом столбце поля.
        begin_1 = 11;                       // Начальный индекс дальнего слева столбца.
        end_1 = 17;                         // Конечный индекс дальнего слева столбца.
        a_1 = -17;                          // Смещение 1 для дальнего слева столбца.
        b_1 = -16;                          // Смещение 2 для дальнего слева столбца.
        c_1 = -15;                          // Смещение 3 для дальнего слева столбца.

        begin_2 = 18;                       // Начальный индекс ближнего слева столбца.
        end_2 = 25;                         // Конечный индекс ближнего слева столбца.
        a_2 = -10;                          // Смещение 1 для ближнего слева столбца.
        b_2 = -7;                           // Смещение 2 для ближнего слева столбца.

        begin_3 = 26;                       // Начальный индекс текущего столбца.
        end_3 = 34;                         // Конечный индекс текущего столбца.

        begin_4 = 35;                       // Начальный индекс ближнего справа столбца.
        end_4 = 42;                         // Конечный индекс ближнего справа столбца.
        a_4 = 7;                            // Смещение 1 для ближнего справа столбца.
        b_4 = 10;                           // Смещение 2 для ближнего справа столбца.

        begin_5 = 43;                       // Начальный индекс дальнего справа столбца.
        end_5 = 49;                         // Конечный индекс дальнего справа столбца.
        a_5 = 15;                           // Смещение 1 для дальнего справа столбца.
        b_5 = 16;                           // Смещение 2 для дальнего справа столбца.
        c_5 = 17;                           // Смещение 3 для дальнего справа столбца.
    }
    if (n >= 35 && n <= 42) {               // Если заданная ячейка находится в шестом столбце поля.
        begin_1 = 18;                       // Начальный индекс дальнего слева столбца.
        end_1 = 25;                         // Конечный индекс дальнего слева столбца.
        a_1 = -18;                          // Смещение 1 для дальнего слева столбца.
        b_1 = -17;                          // Смещение 2 для дальнего слева столбца.
        c_1 = -16;                          // Смещение 3 для дальнего слева столбца.

        begin_2 = 26;                       // Начальный индекс ближнего слева столбца.
        end_2 = 34;                         // Конечный индекс ближнего слева столбца.
        a_2 = -10;                          // Смещение 1 для ближнего слева столбца.
        b_2 = -7;                           // Смещение 2 для ближнего слева столбца.

        begin_3 = 35;                       // Начальный индекс текущего столбца.
        end_3 = 42;                         // Конечный индекс текущего столбца.

        begin_4 = 43;                       // Начальный индекс ближнего справа столбца.
        end_4 = 49;                         // Конечный индекс ближнего справа столбца.
        a_4 = 6;                            // Смещение 1 для ближнего справа столбца.
        b_4 = 9;                            // Смещение 2 для ближнего справа столбца.

        begin_5 = 50;                       // Начальный индекс дальнего справа столбца.
        end_5 = 55;                         // Конечный индекс дальнего справа столбца.
        a_5 = 13;                           // Смещение 1 для дальнего справа столбца.
        b_5 = 14;                           // Смещение 2 для дальнего справа столбца.
        c_5 = 15;                           // Смещение 3 для дальнего справа столбца.
    }
    if (n >= 43 && n <= 49) {               // Если заданная ячейка находится в седьмом столбце поля.
        begin_1 = 26;                       // Начальный индекс дальнего слева столбца.
        end_1 = 34;                         // Конечный индекс дальнего слева столбца.
        a_1 = -17;                          // Смещение 1 для дальнего слева столбца.
        b_1 = -16;                          // Смещение 2 для дальнего слева столбца.
        c_1 = -15;                          // Смещение 3 для дальнего слева столбца.

        begin_2 = 35;                       // Начальный индекс ближнего слева столбца.
        end_2 = 42;                         // Конечный индекс ближнего слева столбца.
        a_2 = -9;                           // Смещение 1 для ближнего слева столбца.
        b_2 = -6;                           // Смещение 2 для ближнего слева столбца.

        begin_3 = 43;                       // Начальный индекс текущего столбца.
        end_3 = 49;                         // Конечный индекс текущего столбца.

        begin_4 = 50;                       // Начальный индекс ближнего справа столбца.
        end_4 = 55;                         // Конечный индекс ближнего справа столбца.
        a_4 = 5;                            // Смещение 1 для ближнего справа столбца.
        b_4 = 8;                            // Смещение 2 для ближнего справа столбца.

        begin_5 = 56;                       // Начальный индекс дальнего справа столбца.
        end_5 = 60;                         // Конечный индекс дальнего справа столбца.
        a_5 = 11;                           // Смещение 1 для дальнего справа столбца.
        b_5 = 12;                           // Смещение 2 для дальнего справа столбца.
        c_5 = 13;                           // Смещение 3 для дальнего справа столбца.
    }
    if (n >= 50 && n <= 55) {               // Если заданная ячейка находится в восьмом столбце поля.
        begin_1 = 35;                       // Начальный индекс дальнего слева столбца.
        end_1 = 42;                         // Конечный индекс дальнего слева столбца.
        a_1 = -15;                          // Смещение 1 для дальнего слева столбца.
        b_1 = -14;                          // Смещение 2 для дальнего слева столбца.
        c_1 = -13;                          // Смещение 3 для дальнего слева столбца.

        begin_2 = 43;                       // Начальный индекс ближнего слева столбца.
        end_2 = 49;                         // Конечный индекс ближнего слева столбца.
        a_2 = -8;                           // Смещение 1 для ближнего слева столбца.
        b_2 = -5;                           // Смещение 2 для ближнего слева столбца.

        begin_3 = 50;                       // Начальный индекс текущего столбца.
        end_3 = 55;                         // Конечный индекс текущего столбца.

        begin_4 = 56;                       // Начальный индекс ближнего справа столбца.
        end_4 = 60;                         // Конечный индекс ближнего справа столбца.
        a_4 = 4;                            // Смещение 1 для ближнего справа столбца.
        b_4 = 7;                            // Смещение 2 для ближнего справа столбца.
    }
    if (n >= 56 && n <= 60) {               // Если заданная ячейка находится в девятом столбце поля.
        begin_1 = 43;                       // Начальный индекс дальнего слева столбца.
        end_1 = 49;                         // Конечный индекс дальнего слева столбца.
        a_1 = -13;                          // Смещение 1 для дальнего слева столбца.
        b_1 = -12;                          // Смещение 2 для дальнего слева столбца.
        c_1 = -11;                          // Смещение 3 для дальнего слева столбца.

        begin_2 = 50;                       // Начальный индекс ближнего слева столбца.
        end_2 = 55;                         // Конечный индекс ближнего слева столбца.
        a_2 = -7;                           // Смещение 1 для ближнего слева столбца.
        b_2 = -4;                           // Смещение 2 для ближнего слева столбца.

        begin_3 = 56;                       // Начальный индекс текущего столбца.
        end_3 = 60;                         // Конечный индекс текущего столбца.
    }

    if (begin_1 != end_1) {                                                     // Вычисление ячеек в дальнем
        if (n + a_1 >= begin_1 && n + a_1 <= end_1)  pV.push_back(n + a_1);     // левом столбце
        if (n + b_1 >= begin_1 && n + b_1 <= end_1)  pV.push_back(n + b_1);     // (если он есть).
        if (n + c_1 >= begin_1 && n + c_1 <= end_1)  pV.push_back(n + c_1);
    }
    if (begin_2 != end_2) {                                                     // Вычисление ячеек в ближнем
        if (n + a_2 >= begin_2 && n + a_2 <= end_2)  pV.push_back(n + a_2);     // левом столбце (если он есть).
        if (n + b_2 >= begin_2 && n + b_2 <= end_2)  pV.push_back(n + b_2);
    }
    if (begin_3 != end_3) {                                                     // Вычисление ячеек в текущем
        if (n - 2 >= begin_3) pV.push_back(n - 2);                              // столбце.
        if (n + 2 <= end_3) pV.push_back(n + 2);
    }
    if (begin_4 != end_4) {                                                     // Вычисление ячеек в ближнем
        if (n + a_4 >= begin_4 && n + a_4 <= end_4)  pV.push_back(n + a_4);     // правом столбце
        if (n + b_4 >= begin_4 && n + b_4 <= end_4)  pV.push_back(n + b_4);     // (если он есть).
    }
    if (begin_5 != end_5) {                                                     // Вычисление ячеек в дальнем
        if (n + a_5 >= begin_5 && n + a_5 <= end_5)  pV.push_back(n + a_5);     // правом столбце
        if (n + b_5 >= begin_5 && n + b_5 <= end_5)  pV.push_back(n + b_5);     // (если он есть).
        if (n + c_5 >= begin_5 && n + c_5 <= end_5)  pV.push_back(n + c_5);
    }
    return pV;
}
/**
 * @brief Game::getNearCells Метод определяет индексы ячеек для ближнего хода.
 * @param n Индекс выбранной ячейки.
 * @return  Вектор индексов ячеек для ближнего хода.
 */
QVector<int8_t> Game::getNearCells(int8_t n) {
    QVector<int8_t> pV;                     // Вектор индексов ячеек для ближнего хода.
    int8_t begin_1 = 0;                     // Начальный индекс левого столбца.
    int8_t end_1 = 0;                       // Конечный индекс левого столбца.
    int8_t a_1 = 0;                         // Смещение 1 для левого столбца.
    int8_t b_1 = 0;                         // Смещение 2 для левого столбца.

    int8_t begin_2 = 0;                     // Начальный индекс текущего столбца.
    int8_t end_2 = 0;                       // Конечный индекс текущего столбца.

    int8_t begin_3 = 0;                     // Начальный индекс правого столбца.
    int8_t end_3 = 0;                       // Конечный индекс правого столбца.
    int8_t a_3 = 0;                         // Смещение 1 для правого столбца.
    int8_t b_3 = 0;                         // Смещение 2 для правого столбца.
//............................................................................................................
    if (n >= 0 && n <= 4) {                 // Если заданная ячейка находится в первом столбце поля.
        begin_2 = 0;                        // Начальный индекс текущего столбца.
        end_2 = 4;                          // Конечный индекс текущего столбца.
        begin_3 = 5;                        // Начальный индекс правого столбца.
        end_3 = 10;                         // Конечный индекс правого столбца.
        a_3 = 5;                            // Смещение 1 для правого столбца.
        b_3 = 6;                            // Смещение 2 для правого столбца.
    }
    if (n >= 5 && n <= 10) {                // Если заданная ячейка находится во втором столбце поля.
        begin_1 = 0;                        // Начальный индекс левого столбца.
        end_1 = 4;                          // Конечный индекс левого столбца.
        a_1 = -6;                           // Смещение 1 для левого столбца.
        b_1 = -5;                           // Смещение 2 для левого столбца.
        begin_2 = 5;                        // Начальный индекс текущего столбца.
        end_2 = 10;                         // Конечный индекс текущего столбца.
        begin_3 = 11;                       // Начальный индекс правого столбца.
        end_3 = 17;                         // Конечный индекс правого столбца.
        a_3 = 6;                            // Смещение 1 для правого столбца.
        b_3 = 7;                            // Смещение 2 для правого столбца.
    }
    if (n >= 11 && n <= 17) {               // Если заданная ячейка находится в третьем столбце поля.
        begin_1 = 5;                        // Начальный индекс левого столбца.
        end_1 = 10;                         // Конечный индекс левого столбца.
        a_1 = -7;                           // Смещение 1 для левого столбца.
        b_1 = -6;                           // Смещение 2 для левого столбца.
        begin_2 = 11;                       // Начальный индекс текущего столбца.
        end_2 = 17;                         // Конечный индекс текущего столбца.
        begin_3 = 18;                       // Начальный индекс правого столбца.
        end_3 = 25;                         // Конечный индекс правого столбца.
        a_3 = 7;                            // Смещение 1 для правого столбца.
        b_3 = 8;                            // Смещение 2 для правого столбца.
    }
    if (n >= 18 && n <= 25) {               // Если заданная ячейка находится в четвертом столбце поля.
        begin_1 = 11;                       // Начальный индекс левого столбца.
        end_1 = 17;                         // Конечный индекс левого столбца.
        a_1 = -8;                           // Смещение 1 для левого столбца.
        b_1 = -7;                           // Смещение 2 для левого столбца.
        begin_2 = 18;                       // Начальный индекс текущего столбца.
        end_2 = 25;                         // Конечный индекс текущего столбца.
        begin_3 = 26;                       // Начальный индекс правого столбца.
        end_3 = 34;                         // Конечный индекс правого столбца.
        a_3 = 8;                            // Смещение 1 для правого столбца.
        b_3 = 9;                            // Смещение 2 для правого столбца.
    }

    if (n >= 26 && n <= 34) {               // Если заданная ячейка находится в пятом столбце поля.
        begin_1 = 18;                       // Начальный индекс левого столбца.
        end_1 = 25;                         // Конечный индекс левого столбца.
        a_1 = -9;                           // Смещение 1 для левого столбца.
        b_1 = -8;                           // Смещение 2 для левого столбца.
        begin_2 = 26;                       // Начальный индекс текущего столбца.
        end_2 = 34;                         // Конечный индекс текущего столбца.
        begin_3 = 35;                       // Начальный индекс правого столбца.
        end_3 = 42;                         // Конечный индекс правого столбца.
        a_3 = 8;                            // Смещение 1 для правого столбца.
        b_3 = 9;                            // Смещение 2 для правого столбца.
    }
    if (n >= 35 && n <= 42) {               // Если заданная ячейка находится в шестом столбце поля.
        begin_1 = 26;                       // Начальный индекс левого столбца.
        end_1 = 34;                         // Конечный индекс левого столбца.
        a_1 = -9;                           // Смещение 1 для левого столбца.
        b_1 = -8;                           // Смещение 2 для левого столбца.
        begin_2 = 35;                       // Начальный индекс текущего столбца.
        end_2 = 42;                         // Конечный индекс текущего столбца.
        begin_3 = 43;                       // Начальный индекс правого столбца.
        end_3 = 49;                         // Конечный индекс правого столбца.
        a_3 = 7;                            // Смещение 1 для правого столбца.
        b_3 = 8;                            // Смещение 2 для правого столбца.
    }
    if (n >= 43 && n <= 49) {               // Если заданная ячейка находится в седьмом столбце поля.
        begin_1 = 35;                       // Начальный индекс левого столбца.
        end_1 = 42;                         // Конечный индекс левого столбца.
        a_1 = -8;                           // Смещение 1 для левого столбца.
        b_1 = -7;                           // Смещение 2 для левого столбца.
        begin_2 = 43;                       // Начальный индекс текущего столбца.
        end_2 = 49;                         // Конечный индекс текущего столбца.
        begin_3 = 50;                       // Начальный индекс правого столбца.
        end_3 = 55;                         // Конечный индекс правого столбца.
        a_3 = 6;                            // Смещение 1 для правого столбца.
        b_3 = 7;                            // Смещение 2 для правого столбца.
    }
    if (n >= 50 && n <= 55) {               // Если заданная ячейка находится в восьмом столбце поля.
        begin_1 = 43;                       // Начальный индекс левого столбца.
        end_1 = 49;                         // Конечный индекс левого столбца.
        a_1 = -7;                           // Смещение 1 для левого столбца.
        b_1 = -6;                           // Смещение 2 для левого столбца.
        begin_2 = 50;                       // Начальный индекс текущего столбца.
        end_2 = 55;                         // Конечный индекс текущего столбца.
        begin_3 = 56;                       // Начальный индекс правого столбца.
        end_3 = 60;                         // Конечный индекс правого столбца.
        a_3 = 5;                            // Смещение 1 для правого столбца.
        b_3 = 6;                            // Смещение 2 для правого столбца.
    }
    if (n >= 56 && n <= 60) {               // Если заданная ячейка находится в девятом столбце поля.
        begin_1 = 50;                       // Начальный индекс левого столбца.
        end_1 = 55;                         // Конечный индекс левого столбца.
        a_1 = -6;                           // Смещение 1 для левого столбца.
        b_1 = -5;                           // Смещение 2 для левого столбца.
        begin_2 = 56;                       // Начальный индекс текущего столбца.
        end_2 = 60;                         // Конечный индекс текущего столбца.
    }

    if (begin_1 != end_1) {                                                     // Вычисление ячеек в левом
        if (n + a_1 >= begin_1 && n + a_1 <= end_1)  pV.push_back(n + a_1);     // столбце (если он есть).
        if (n + b_1 >= begin_1 && n + b_1 <= end_1)  pV.push_back(n + b_1);
    }
    if (begin_2 != end_2) {                                                     // Вычисление ячеек в текущем
        if (n - 1 >= begin_2) pV.push_back(n - 1);                              // столбце.
        if (n + 1 <= end_2) pV.push_back(n + 1);
    }
    if (begin_3 != end_3) {                                                     // Вычисление ячеек в правом
        if (n + a_3 >= begin_3 && n + a_3 <= end_3)  pV.push_back(n + a_3);     // столбце (если он есть).
        if (n + b_3 >= begin_3 && n + b_3 <= end_3)  pV.push_back(n + b_3);
    }
    return pV;
}
/**
 * @brief Game::getTransferMoveCells Метод возвращает индексы ячеек доступных для выполнения дальнего хода.
 * @param field Состояние игрового поля.
 * @param n Индекс ячейки, для которой вычисляются ходы.
 * @return Вектор индексов доступных для хода ячеек.
 */
QVector<int8_t> Game::getTransferMoveCells(QVector<int8_t> const& field, int8_t n) {
    QVector<int8_t> pV = getFarCells(n);                        // Вектор для сохранения найденных ячеек.
    QVector<int8_t>::iterator it;                               // Итератор для выполнения алгоритма поиска.
    for (int i = 0; i < field.size(); i++) {                    // Перебор всех ячеек игрового поля,
        if (field[i] != 0) {                                    // и если ячейка не пустая, ее индекс
            QVector<int8_t>::iterator it                        // находится в векторе pV,
                    = std::find(pV.begin(), pV.end(), i);       // он удаляется.
            if (it != pV.end()) {
                pV.erase(it);
            }
        }
    }
    return pV;                                                  // Оставшиеся индексы пустых ячеек возвращается.
}
//............................................................................................................
//......................................... private methods ..................................................
//............................................................................................................
/**
 * @brief Game::changePlayer Метод меняет игроков.
 */
void Game::changePlayer(){
     activePlayer = (activePlayer==1)?2:(activePlayer==2)?1:0;  // Смена игрока.
     emit transmitPlayer(activePlayer);                         // Сигнал о смене игрока.
     emit transmitScore(counterChips(1), counterChips(2));      // Сигнал для передачи счета игры.
     if (activePlayer==0){
         qDebug()<<"Ошибка: Неправильный номер игрока!";        // Проверка игрока (для отладки).
         exit(-1);
     }
 }
/**
 * @brief Game::checkMoves Метод проверяет наличие ходов игрока.
 * @param player Номер игрока, для которого выполняется поиск.
 * @return
 */
bool Game::checkMoves(int8_t player){
    QVector<int8_t> addVec;                         // Вектор для хранения индексов ячеек для ближнего хода.
    QVector<int8_t> stepVec;                        // Вектор для хранения индексов ячеек для дальнего хода.
    for (int8_t i = 0; i < field.size(); i++) {     // Перебор всех ячеек в поисках фишки игрока.
      if (field[i] == player) {                     // Если фишка игрока найдена.
          stepVec = getTransferMoveCells(field, i); // Получаем  вектор свободных ячеек для дальних ходов.
          addVec = getAddMoveCells(field, i);       // Получение вектора свободных ячеек для ближних ходов.
          if (!addVec.empty()||!stepVec.empty()){
              return true;                          // Если один из векторов не пустой, то ход есть.
          }
      }
    }
    return false;                                   // Если оба вектора всегда пустые, ходов нет.
}
/**
 * @brief Game::checkScore Оценочная функция игры "Гексогон".
 * @param field Конфигурация игрового поля.
 * @param player Игрок, для которого выполняется вычисление оценочной функции.
 * @return Разница между количеством фишек игрока и противника.
 */
int Game::checkScore(QVector<int8_t> const& field, int player) {
    int counter = 0;                                    // Разница в количестве фишек игрока и противника.
    int enemy = getOpponent(player);                    // Вычисление значения противника.
    for (auto a : field) {                              // Перебор всех позиций игрового поля.
        if (a == player) counter++;                     // Если обнаружена фишка игрока +1.
        if (a == enemy) counter--;                      // Если обнаружена фишка противника -1.
    }
    return counter;                                     // Возвращается разница.
}
/**
 * @brief Game::counterChips Метод выполняет подсчет количества фишек указанного игрока.
 * @param player Игрок, фишки которого пересчитываются.
 * @return Количество фишек.
 */
int Game::counterChips(int8_t player){
    int counter = 0;                                    // Счетчик фишек.
    for(auto a : field){                                // Перебор всех ячеек игрового поля.
        if (a == player){                               // Если значение в ячейке совпадает с номером.
            counter++;                                  // игрока, счетчик увеличивается.
        }
    }
    return counter;
}
/**
 * @brief Game::createAvailableMove Метод определения доступных ходов для человека.
 * @param index Индекс ячейки игрового поля, для которого выполняется поиск.
 */
void Game::createAvailableMove(int index){
    currentIndex = index;                               // Сохранение текущего индекса в поле.
    addMoveCells =
            getAddMoveCells(field, index);              // Получения индексов ячеек для ходов с добавлением.
    transferMoveCells =
            getTransferMoveCells(field, index);         // Получения индексов ячеек ходов с перестановкой.
    emit transmitMoveCells(addMoveCells,
                           transferMoveCells);          // Сигнал передачи свободных ходов.
}
/**
 * @brief Game::doMove Метод выполнения хода по структуре Move.
 * @param field Состояние игрового поля.
 * @param move Ход игрока, упакованный в структуру.
 */
void Game::doMove(QVector<int8_t>& field, Move &move) {
    int player = field[move.beginPostion];              // Игрок делающий ход, на в исходной позиции.
    int enemy = getOpponent(player);                    // Вычисление противника.
    if (move.clearBeginPostion) {                      // Если ход с очисткой начальной позиции,
        field[move.beginPostion] = 0;                   // очищаем ее.
    }
    field[move.newPostion] = player;                    // Устанавливаем фишку в новую позицию.
    QVector<int8_t> tmpArountCells =
            getNearCells(move.newPostion);              // Вектор ячеек вокруг новой позиции.
    for (auto a : tmpArountCells) {                     // Если вокруг фишки есть противник,
        if (field[a] == enemy) field[a] = player;       // его фишки перекрашиваются.
    }
}
/**
 * @brief Game::findWinner Метод ищет победителя, и если находит, выдает сообщение и останавливает игру.
 * @return Наличие победителя, если найден - true, если нет false.
 */
bool Game::findWinner(){
    if (checkMoves(activePlayer)){                              // Если для активного игрока есть ходы
        return false;                                           // игра продолжается.
    }
    QString mess = "Игра закончена в ничью.";                   // Сорока сообщение.
    if (modeGame == Mode::humanVShuman){                        // Если режим игра человек против человека,
        int humanScore_1 = counterChips(humanPlayer_1);         // пересчет фишек первого игрока,
        int humanScore_2 = counterChips(humanPlayer_2);         // пересчет фишек второго игрока.
        if (humanScore_1 > humanScore_2){                       // Если у первого фишек больше,
           mess="Игрок номер один выиграл!";                    // он выиграл.
        }
        else if (humanScore_1 < humanScore_2){                  // Если больше у второго,
           mess="Игрок номер два выиграл!";                     // выиграл второй.
        }
    }
    if (modeGame == Mode::humanVSpc){                           // Если режим игры человек против компьютера,
        int humanScore = counterChips(humanPlayer);             // пересчет фишек игрока(человека),
        int computerScore = counterChips(computerPlayer);       // пересчет фишек компьютера.
        if (humanScore > computerScore){                        // Если у игрока фишек больше,
           mess="Поздравляю, Вы выиграли!";                     // игрок выиграл.
        }
        else if (humanScore < computerScore){                   // Если у компьютера фишек больше,
           mess="Увы, компьютер выиграл!";                      // компьютер выиграл.
        }
    }
    if (modeGame == Mode::pcVSpc){                              // Если режим игры компьютер против компьютера,
        int computerScore_1 = counterChips(computerPlayer_1);   // пересчет фишек компьютера 1,
        int computerScore_2 = counterChips(computerPlayer_2);   // пересчет фишек компьютера 2.
        if (computerScore_1 > computerScore_2){                 // Если фишек компьютера 1 больше,
           mess="Компьютер номер один выиграл!";                // Компьютер 1 победил.
        }
        else if (computerScore_1 < computerScore_2){            // Если фишек компьютера 2 больше,
           mess="Компьютер номер два выиграл!";                 // победил компьютер 2.
        }
    }
    QMessageBox msgBox;                                         // Объект диалогового окна сообщения.
    msgBox.setText(mess);                                       // Установка текста сообщения.
    msgBox.setIcon(QMessageBox::Information);                   // Установка иконки сообщения.
    msgBox.exec();                                              // Запуск отображения окна.
    gameReset();                                                // Завершение игры.
    emit gameOver();                                            // Сигнал о завершении игры.
    return true;                                                // Победитель найден.
}
/**
 * @brief Game::generateMoves Функция генерации возможных ходов игрока.
 * @param [in] field Состояние игрового поля.
 * @param [out] moves Вектор для сохранения доступных ходов.
 * @param player Игрок, для которого определяются ходы.
 * @return Наличие возможных ходов, true - ход есть, false - ходов нет.
 */
bool Game::generateMoves(QVector<int8_t> const& field, QVector<Move>& moves, int player) {
    QVector<int8_t> addVec;                            // Вектор индексов соседних ячеек, доступных для хода.
    QVector<int8_t> stepVec;                           // Вектор индексов дальних ячеек, доступных для хода.
    moves.clear();                                     // Очистка вектора возможных ходов.
    for (int8_t i = 0; i < field.size(); i++) {        // Перебор всех ячеек в поисках фишки игрока.
        if (field[i] == player) {                      // Если фишка игрока найдена.
            stepVec = getTransferMoveCells(field, i);  // Заполнение векторов соседних ячеек данными.
            addVec = getAddMoveCells(field, i);        // Заполнение векторов дальних ячеек данными.
            for (auto a : addVec) {                    // Поиск возможных ходов в ближние ячейки.
                moves.push_back(Move{i, a, false});    // Добавление хода в вектор доступных ходов.
            }
            for (auto a : stepVec) {                   // Поиск возможных ходов в дальние ячейки.
                moves.push_back(Move{i, a, true});     // Добавление хода в вектор доступных ходов.
            }
        }
    }
    if (moves.empty()) return false;                    // Если вектор доступных ходов пуст,
    return true;                                        // возвращается false, если в нем что то есть - true.
}
/**
 * @brief Game::getOpponent Метод возвращает значение противника.
 * @param player Игрок, для которого определяется противник.
 * @return Значение противника.
 */
int8_t Game::getOpponent(int8_t player){
    int opponent = (player == 1) ? 2 : (player == 2) ? 1 : 0;   // Значение противника.
    if (opponent == 0){
        qDebug() << "Ошибка: Неправильно выбран игрок!";        // Проверка противника и игрока.
        exit(-1);                                               // Завершение программы.
    }
    return opponent;                                            // Возврат значения противника.
}
/**
 * @brief Game::indexMaxItem Метод поиска наибольшего элемента в массиве.
 * @param Vec Вектор входных данных.
 * @return Индекс наибольшего элемента.
 */
int Game::indexMaxItem(QVector<int> const& Vec){
    int indexMaxScore = -1;                                     // Индекс наибольшего элемента в векторе.
    if (!Vec.empty()){                                          // Если вектор не пустой.
        indexMaxScore = 0;                                      // Индекс равен нулевому.
        int maxScore = Vec[0];                                  // Максимальный элемент в векторе.
        for (int i=0; i<Vec.size(); i++){                       // Перебор всех элементов в векторе.
            if(Vec[i] > maxScore){                              // Если элемент вектора больше найденного,
                maxScore = Vec[i];                              // сохраняется этот элемент как наибольший
                indexMaxScore = i;                              // сохраняется его индекс.
            }
        }
    }
    return indexMaxScore;                                       // Возврат индекса найденного элемента.
}
/**
 * @brief Game::makeComputerMove Метод выполняет ход компьютера после завершения поиска хода.
 */
void Game::makeComputerMove(){
    Move move = future->result();                           // Объект будущего возвращает значение хода.
    doMove(field, move);                                    // Выполняется ход.
    emit makeMove(move.beginPostion,                        // Отправка согнала о необходимости сделать ход.
                  move.newPostion, activePlayer,            // Может быть принят графическим виджетом.
                  move.clearBeginPostion);
}
/**
 * @brief Game::miniMax Функция оценки ходов методом миниМакса с альфа-бета отсечением.
 * @param field Состояние игрового поля.
 * @param player Игрок, который должен выполнить ход.
 * @param masterPlayer Игрок в отношении которого определяется оценка.
 * @param depth Глубина рекурсии алгоритма.
 * @param level Текущий уровень рекурсии (по умолчанию равен 0, не требует изменения).
 * @param alpha Коэффициент альфа (по умолчанию равен минимальному int, не требует изменения).
 * @param beta Коэффициент бета (по умолчанию равен максимальному int, не требует изменения).
 * @return Значение оценочной функции для выбранного хода, относительно игрока masterPlayer.
 */
int Game::miniMax(QVector<int8_t> const& field, int player, int masterPlayer,
                  int depth, int level, int alpha, int beta) {
    if (depth == level) {                                   // Если достигнута заданная глубина рекурсии.
        return checkScore(field, masterPlayer);             // Возвращаем оценку.
    }
    int enemy = getOpponent(player);                        // Вычисление значения противника.
    int score = level % 2 == 0 ? INT_MAX : INT_MIN;         // Если уровень минимизирующий, то score
                                                            // максимальное если уровень максимизирующий,
                                                            // score минимальное.
//....................... Создание всевозможные ходов, которые могут быть сыграны. ............................
    QVector<Move>moves;                                     // Вектор для хранения всевозможных ходов игрока.
    if (!generateMoves(field, moves, player)) {             // Если ходов нету,
        score = checkScore(field, masterPlayer);            // считаем оценку позиции.
        if (score > 0) {                                    // Если счет в пользу masterPlayer,
            return INT_MAX;                                 // это победа и значение функции максимально.
        }                                                   // Если проигрыш или ничья,
        else return INT_MIN;                                //значение функции минимально.
    }
//................................ Рекурсивная проверка всех найденных ходов. .................................
    for (auto i = 0; i < moves.size(); i++) {               // Перебор всех ходов.
        if (alpha < beta) {                                 // Проверка условия альфа-бета.
            QVector<int8_t> tmpField = field;               // Временное поле для отогревания хода.
            doMove(tmpField, moves[i]);                     // Выполнение хода на игроком поле.
            int result = miniMax(tmpField, enemy,
                                 masterPlayer, depth,
                                 level + 1, alpha, beta);   // Рекурсивный запуск алгоритма миниМакса.
//........................ Вычисление алфа и бэта, выбор предпочтительной оценки. ............................
            if (level % 2 == 0) {                           // Если уровень минимизации результата,
                if (result < score) score = result;         // выбираем наименьшую оценку
                if (beta > result) beta = result;           // и определяем бету как наименьшую оценку из
            }                                               // уже просчитанных ветвей дерева.
            else {                                          // Если уровень максимизации результата,
                if (result > score) score = result;         // выбираем наибольшую оценку
                if (alpha < result) alpha = result;         // и определяем альфу как наибольшую оценку из
            }                                               // уже просчитанных ветвей дерева.
        }
        else {                                              // Если условие альфа-бета не выполняется,
            break;                                          // просчет ходов на уровне заканчивается.
        }
    }
//.......................... Возвращается результат оценки на текущем уровне. .................................
    return score;
}
/**
 * @brief Game::selectComputerMove Метод выполняет выбор хода для компьютера.
 * @param field Текущее состояние игрового поля.
 * @param player Номер игрока для которого производится вычисление.
 * @param depth Глубина алгоритма поиска решения.
 * @return Наиболее оптимальный ход.
 */
Game::Move Game::selectComputerMove(QVector<int8_t>& field, int player, int depth) {
    int enemy = getOpponent(player);
//..................... Создание всевозможных ходов, которые может отыграть компьютер. ........................
    QVector<Move>moves;                                             // Вектор всевозможных ходов игрока.
    if (!generateMoves(field, moves, player)) {
        return Move{0,0,0};
    }
//.................................. Проверка ходов алгоритмом миниМакса. ....................................
    QVector<int> score;                                             // Вектор для хранения оценок ходов.
    for (auto &a : moves) {
        QVector<int8_t> tmpField = field;                           // Временно поле для отыгрыша хода.
        doMove(tmpField, a);
        score.push_back(miniMax(tmpField, enemy, player, depth));   // Запуск алгоритма миниМакса.
    }
//............................. Случайный выбор одного из наиболее выгодных ходов. ...........................
    auto it = std::max_element(score.begin(),score.end());          // Поиск значения максимальной оценки.
    int maxItem = *it;                                              // Получение значения по итератору.
    QVector<int>indexMaxItem;                                       // Индексы ходов с максимальной оценкой.
    for (int i = 0; i<score.size(); i++){                           // Заполнение вектора индексами
        if (score[i] == maxItem){                                   // ходов с максимальной оценкой.
            indexMaxItem.push_back(i);
        }
    }
    srand(time(NULL));                                              // Настройка генератора случайных чисел.
    int randIndexMove = indexMaxItem[rand()%indexMaxItem.size()];   // Получение индекса выбранного хода.
    return moves[randIndexMove];                                    // Возврат выбранного выгодного хода.
}
/**
 * @brief Game::startComputerMove Метод запускает вычисление хода компьютера в параллельном потоке.
 */
void Game::startComputerMove(){
    int gameDepth;                                                  // Глубина рекурсии алгоритма миниМакса.
    if (modeGame == Mode::humanVSpc){                               // Если человек против компьютера,
        gameDepth = gameDepth_1;                                    // Берется глубина рекурсии первого ПК.
    } else                                                          // Иначе,
    if (modeGame == Mode::pcVSpc){                                  // если ПК играет сам с собой,
        if (activePlayer == computerPlayer_1){                      // для каждого ПК принимается
            gameDepth = gameDepth_1;                                // своя глубина рекурсии
        } else                                                      // соответственно.
        if (activePlayer == computerPlayer_2){
            gameDepth = gameDepth_2;
        }
    }
    // Запускается метод вычисления хода в параллельном потоке.
    *future = QtConcurrent::run(this, &Game::selectComputerMove, field, activePlayer, gameDepth);
    timer->start(timeOutComputerMove);                              // Задержка для вычисления хода.
    state = State::witePcMove;                                      // Автомат в режим ожидания хода ПК.
    connect(timer, SIGNAL(timeout()), this, SLOT(computerMove()));  // Слот обработки вычисления хода.
}
//............................................................................................................
//........................................... public slots ...................................................
//............................................................................................................
/**
 * @brief Game::makeGame Метод игрового режима Человек-Человек, и человек компьютер.
 * @param index Индекс ячейки поля, полученный от графического виджета.
 */
void Game::makeGame(int index){
//.......................................... Состояние ожидания ..............................................
    if (state == State::none){                                  //Ничего не делаем, пока автомат не запущен.
        return;
    }
//.................... Состояние ожидания индекса ячейки для определения доступных ходов .....................
    if (state == State::waitIndex){
        if (field[index] == activePlayer){
            createAvailableMove(index);                         // Определение доступных ходов.
            state = State::humanMove;                           //Автомат ожидает хода игрока.
        }
        return;
    }
//..................................... Состояние выполнение хода игрока .....................................
    if (state == State::humanMove){
        if (field[index] == activePlayer){                      // Если человек снова выбирает свою фишку,
            createAvailableMove(index);                         // определение доступных ходов.
            state = State::humanMove;                           // Автомат в состояние ожидания хода игрока.
            return;
        }
        else{                                                   // Если выбрано любое другое поле.
                Move move;
                QVector<int8_t>::iterator itAddMove =           // Поиск выбранного поля для хода в области
                        std::find(addMoveCells.begin(),         // доступных ближних ходов.
                                  addMoveCells.end(), index);   // Итератор для поиска ближних ходов.
                if (itAddMove != addMoveCells.end()){           // Если поле находится в области ближних
                    move.beginPostion = currentIndex;           // ходов и свободно, создается структура хода:
                    move.newPostion = index;                    // начальная позиция фишки, конечная позиция
                    move.clearBeginPostion = false;            // фишки и надо ли очистить начальную позицию.
                }
                else {                                          // Если ход не найден в области ближних ходов,
                    QVector<int8_t>::iterator itTransferMove =  // Поиск выбранного поля для хода в области
                     std::find(transferMoveCells.begin(),       // доступных дальних ходов.
                              transferMoveCells.end(), index);  // Итератор для поиска дальних ходов.
                    if (itTransferMove !=
                            transferMoveCells.end()){           // Если поле находится в области дальних
                        move.beginPostion = currentIndex;       // ходов и свободно, создается структура хода:
                        move.newPostion = index;                // начальная позиция фишки, конечная позиция
                        move.clearBeginPostion = true;         // фишки и надо ли очистить начальную позицию.
                    }else{                                      // Если в выбранное поле сделать ход нельзя,
                        emit clearAvailableMove();              // Сигнал для отмены отображения доступных
                        state = State::waitIndex;               // ходов. Автомат в состояние ожидания
                        return;                                 // выбора фишки человеком. Выход из метода.
                    }
                }
                doMove(field, move);                            // Полученный ход выполняется.
                emit clearAvailableMove();                      // Сигнал отмены отображения доступных ходов.
                emit makeMove(move.beginPostion,
                              move.newPostion,
                              activePlayer,
                              move.clearBeginPostion);         // Выполнить ход на виджете.
                changePlayer();                                 // Смена игрока.
                findWinner();                                   // Проверка на наличие победителя.
                if (modeGame == Mode::humanVShuman){            // Если режим человек-человек,
                    state = State::waitIndex;                   // автомат переходит в состояние ожидания
                }                                               // выбора фишки игроком.
                else if (modeGame == Mode::humanVSpc){          // Если режим игры человек-компьютер,
                    state = State::pcMove;                      // автомат переходит в состояние хода ПК.
                    computerMove();
                }
        }
    }
}
//............................................................................................................
//........................................... private slots ...................................................
//............................................................................................................
/**
 * @brief Game::computerMove Метод выполняет ход компьютера (полный ход, от начала до конца)
 */
void Game::computerMove(){
     if (!timer->isActive()){                              // Если выполнение хода не запущено и таймер стоит.
         startComputerMove();                              // Запускается выполнение хода.
     }
     else{
         if(future->isRunning()){                          // Если вычисление хода ПК еще не окончено
             timer->start(50);                             // Таймер перезапускается с меньшей выдержкой.
             return;                                       // Функция не меняет состояние игрового автомата.
         }
         else{                                             // Если вычисление закончено, выполняется ход.
             timer->stop();                                // Таймер выключается.
             disconnect(timer, SIGNAL(timeout()),
                        this, SLOT(computerMove()));       // Соединение сигнал - слот разбирается.
             makeComputerMove();                           // Выполнение хода компьютером.
             changePlayer();                               // Смена текущего игрока.
             if (!findWinner()){                           // Если победителя еще нет,
                 if (modeGame == Mode::humanVSpc){         // и если идет игра человека с ПК,
                     state = State::waitIndex;             // состояние меняется на ожидание индекса позиции.
                 }else {                                   // Иначе состояние игрового автомата не меняется,
                     startComputerMove();                  // снова запускается ход компьютера, но другого.
                 }
             }
         }
     }
}
